<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>STL Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#ffffff; }
    #c { width:100%; height:100%; display:block; }
    #hint {
      position: absolute; left: 12px; bottom: 10px; font: 12px/1.2 system-ui, sans-serif;
      color: #222; background: rgba(255,255,255,.8); padding: 6px 8px; border-radius: 6px;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="hint">Arrastra para rotar · Rueda para zoom · Shift+arrastrar para pan</div>

  <!-- Three & helpers desde CDN -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.157.0/examples/jsm/controls/OrbitControls.js';
    import { STLLoader } from 'https://unpkg.com/three@0.157.0/examples/jsm/loaders/STLLoader.js';

    // ==== Utilidades ====
    const params = new URLSearchParams(location.search);
    const src = params.get('src'); // URL del STL (obligatorio)
    const bg  = params.get('bg') || '#ffffff';

    if (!src) {
      document.body.innerHTML = '<p style="padding:16px;font:14px system-ui">Falta ?src=URL_DEL_STL</p>';
      throw new Error('No STL URL');
    }

    // ==== Escena ====
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setClearColor(new THREE.Color(bg), 1);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 1000);
    camera.position.set(200, 120, 200);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.enablePan = true;
    controls.panSpeed = 0.6;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.7;

    // Luces
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // Suelo sutil (opcional)
    const grid = new THREE.GridHelper(1000, 20, 0x999999, 0xdddddd);
    grid.position.y = -0.01;
    scene.add(grid);

    // ====== Carga STL ======
    const loader = new STLLoader();
    loader.load(
      src,
      (geom) => {
        // Material oscuro con ligera emisividad para que “se vea”
        const mat = new THREE.MeshStandardMaterial({
          color: 0x0f172a, metalness: 0.1, roughness: 0.9
        });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.castShadow = true; mesh.receiveShadow = true;
        scene.add(mesh);

        // ---- Centrado y encuadre ----
        geom.computeBoundingBox();
        const bb = geom.boundingBox;
        const size = new THREE.Vector3();
        bb.getSize(size);
        const center = new THREE.Vector3();
        bb.getCenter(center);

        // Centrar al origen
        mesh.position.sub(center);

        // Colocar cámara para “fit to view”
        const maxDim = Math.max(size.x, size.y, size.z);
        const fitHeightDistance = maxDim / (2 * Math.tan((Math.PI * camera.fov) / 360));
        const fitWidthDistance  = fitHeightDistance / camera.aspect;
        const distance = 1.3 * Math.max(fitHeightDistance, fitWidthDistance);

        const dir = new THREE.Vector3(1, 0.7, 1).normalize(); // ángulo agradable
        camera.position.copy(dir.multiplyScalar(distance));
        camera.near = distance / 100;
        camera.far  = distance * 100;
        camera.updateProjectionMatrix();

        controls.target.set(0, 0, 0);
        controls.update();
      },
      undefined,
      (err) => {
        console.error('Error cargando STL', err);
        const msg = document.createElement('div');
        msg.style.cssText = 'position:absolute;top:10px;left:10px;background:#fff;padding:8px;border-radius:6px;font:12px system-ui';
        msg.textContent = 'No se pudo cargar el STL';
        document.body.appendChild(msg);
      }
    );

    // ==== Resize ====
    function resizeRendererToDisplaySize() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
      return needResize;
    }

    // ==== Animación ====
    function render() {
      resizeRendererToDisplaySize();
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

    // Ajuste inicial al tamaño de la ventana
    const setFull = () => {
      canvas.style.width = '100%';
      canvas.style.height = '100%';
    };
    setFull();
    window.addEventListener('resize', setFull);
  </script>
</body>
</html>
